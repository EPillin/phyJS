<!DOCTYPE html>
<html lang="en" style="height: 100%;">
<head>
    <meta charset="UTF-8">
    <title>Rotation</title>
    <style>
        circle {
            transition: r 0.5s; /* chrome only for now :( */
        }
    </style>
</head>
<body style="height: 100%; margin: 0">
<svg id="frame" height="100%" width="100%"></svg>
<script>

    var dt = .01;
    var base_density = 10;
    var n_objs = 0;

    var update_period = 10;
    var probe_period = 1000;

    var max_velocity = 10;
    var max_r = 30;

    var G = .5;
    var E_scale = .000001;

    function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }


    function Vxy(v1x, v1y, v2x = 0, v2y = 0) {
        return Math.sqrt((v1x - v2x) * (v1x - v2x) + (v1y - v2y) * (v1y - v2y));
    }

    function kinetic_E(m, v) {
        return E_scale * 0.5 * m * v * v;
    }

    function binding_E(m, r) {
        return E_scale * .6 * G * m * m / r;
    }

    function potential_E(m1, m2, d) {
        return E_scale * -G * m1 * m2 / d;
    }

    var frame = document.getElementById("frame");

    var starting_objects = [
        // {name: "obj1", cx: 500, cy: 300, r: 80, fill: "rgb(255,255,0)", "fill-opacity": "0.8", vx: 0, vy: 0},
        {name: "obj1", cx: 500, cy: 100, r: 22, fill: "rgb(247,8,76)", "fill-opacity": "0.8", vx: 0, vy: 0},
        {name: "obj2", cx: 500, cy: 500, r: 22, fill: "rgb(5,130,202)", "fill-opacity": "0.8", vx: 0, vy: 0},
        // {name: "obj3", cx: 150, cy: 250, r: 20, fill: "#0582ca", "fill-opacity": "0.8", vx: -5, vy: 5},
    ];
    for (let i = 0; i < n_objs; ++i) {
        starting_objects.push({
                name: i,
                cx: randInt(frame.getBoundingClientRect().width / 4, frame.getBoundingClientRect().width / 2 + frame.getBoundingClientRect().width / 4),
                cy: randInt(frame.getBoundingClientRect().width / 4, frame.getBoundingClientRect().height / 2 + frame.getBoundingClientRect().height / 4),
                r: randInt(1, max_r),
                fill: `rgb(${randInt(0, 255)}, ${randInt(0, 255)}, ${randInt(0, 255)})`,
                // "fill-opacity": Math.random(),
                "fill-opacity": 1,
                vx: randInt(-max_velocity, max_velocity),
                vy: randInt(-max_velocity, max_velocity),
                // vx: 0,
                // vy: 0
            }
        );
    }
    // Init
    for (var obj of starting_objects) {

        var element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        for (var prop in obj) {
            element.setAttribute(prop, obj[prop]);
        }
        frame.appendChild(element);
    }

    function resolve_collisions(node) {
        for (var obj1 of node.childNodes) {
            for (var obj2 of node.childNodes) {
                if (obj1 !== obj2) {
                    var x1 = parseFloat(obj1.getAttribute("cx"));
                    var y1 = parseFloat(obj1.getAttribute("cy"));

                    var x2 = parseFloat(obj2.getAttribute("cx"));
                    var y2 = parseFloat(obj2.getAttribute("cy"));

                    var r1 = parseFloat(obj1.getAttribute("r"));
                    var r2 = parseFloat(obj2.getAttribute("r"));

                    var d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                    if (d < r1 + r2) {
                        r2 *= d / (r2 + r1);

                        var v1_x = parseFloat(obj1.getAttribute("vx"));
                        var v1_y = parseFloat(obj1.getAttribute("vy"));
                        var density1 = parseFloat(obj1.getAttribute("fill-opacity"));
                        var m1 = r1 * r1 * r1 * base_density * density1;

                        var v2_x = parseFloat(obj2.getAttribute("vx"));
                        var v2_y = parseFloat(obj2.getAttribute("vy"));
                        var density2 = parseFloat(obj2.getAttribute("fill-opacity"));
                        var m2 = r2 * r2 * r2 * base_density * density2;

                        var m = m1 + m2;

                        if (m1 > m2) {
                            var x = x1, y = y1;
                        } else {
                            var x = x2, y = y2;
                        }
                        // var x = (m1 * x1 + m2 * x2) / m;
                        // var y = (m1 * y1 + m2 * y2) / m;

                        var v_x = (m1 * v1_x + m2 * v2_x) / m;
                        var v_y = (m1 * v1_y + m2 * v2_y) / m;

                        var density = (m1 * density1 + m2 * density2) / m;

                        var r = Math.cbrt(m / (base_density * density));

                        var rgb1 = obj1.getAttribute('fill').match(/\d+/g).map((e) => parseFloat(e));
                        var rgb2 = obj2.getAttribute('fill').match(/\d+/g).map((e) => parseFloat(e));

                        var rgb = rgb1.map((e, i) => Math.round((m1 * e + m2 * rgb2[i]) / m));

                        var v1 = Vxy(v1_x, v1_y);
                        var v2 = Vxy(v2_x, v2_y);
                        var v = Vxy(v_x, v_y);
                        console.log({
                            Ec1: kinetic_E(m1, v1),
                            Ec2: kinetic_E(m2, v2),
                            Ec: kinetic_E(m, v),
                            diffEc: kinetic_E(m, v) - kinetic_E(m1, v1) - kinetic_E(m2, v2)
                        });
                        console.log({
                            Eb1: binding_E(m1, r1),
                            Eb2: binding_E(m2, r2),
                            Eb: binding_E(m, r),
                            diffEb: binding_E(m, r) - binding_E(m1, r1) - binding_E(m2, r2)
                        });

                        obj1.setAttribute("density", density);
                        obj1.setAttribute("cx", x);
                        obj1.setAttribute("cy", y);
                        obj1.setAttribute("vx", v_x);
                        obj1.setAttribute("vy", v_y);

                        obj1.setAttribute("r", r);
                        obj1.setAttribute("fill", `rgb(${rgb.join(',')})`);
                        frame.removeChild(obj2);
                        return true;
                    }
                }
            }
        }
        return false;
    }


    function update_velocity(node) {
        for (var obj1 of node.childNodes) {
            for (var obj2 of node.childNodes) {
                if (obj1 !== obj2) {
                    var x1 = parseFloat(obj1.getAttribute("cx"));
                    var y1 = parseFloat(obj1.getAttribute("cy"));

                    var x2 = parseFloat(obj2.getAttribute("cx"));
                    var y2 = parseFloat(obj2.getAttribute("cy"));

                    var r1 = parseFloat(obj1.getAttribute("r"));
                    var r2 = parseFloat(obj2.getAttribute("r"));

                    var d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                    if (d < r1 + r2) {
                        r2 *= d / (r2 + r1);
                    }

                    var density2 = parseFloat(obj2.getAttribute("fill-opacity"));
                    var m2 = r2 * r2 * r2 * base_density * density2;

                    var F = G * m2 / (d * d * d);

                    var v1_x = parseFloat(obj1.getAttribute("vx"));
                    var v1_y = parseFloat(obj1.getAttribute("vy"));

                    obj1.setAttribute("vx", v1_x + (x2 - x1) * F * dt);
                    obj1.setAttribute("vy", v1_y + (y2 - y1) * F * dt);
                }
            }
        }
    }

    function update_position(node) {
        for (var obj of node.childNodes) {
            var x = parseFloat(obj.getAttribute("cx"));
            var y = parseFloat(obj.getAttribute("cy"));
            var vx = parseFloat(obj.getAttribute("vx"));
            var vy = parseFloat(obj.getAttribute("vy"));
            obj.setAttribute("cx", x + vx * dt);
            obj.setAttribute("cy", y + vy * dt);
        }
    };

    function analyse_system(node) {
        var kinetic = 0;
        var potential = 0;
        var binding = 0;
        var lightest = Infinity;
        var heaviest = 0;
        var slowest = Infinity;
        var fastest = 0;
        var mass = 0;

        for (var obj1 of node.childNodes) {

            var v1_x = parseFloat(obj1.getAttribute("vx"));
            var v1_y = parseFloat(obj1.getAttribute("vy"));

            var r1 = parseFloat(obj1.getAttribute("r"));

            var density1 = parseFloat(obj1.getAttribute("fill-opacity"));
            var m1 = r1 * r1 * r1 * base_density * density1;

            var v1 = Math.sqrt(v1_x * v1_x + v1_y * v1_y);

            kinetic += kinetic_E(m1, v1);
            binding += binding_E(m1, r1);

            lightest = m1 < lightest ? m1 : lightest;
            heaviest = m1 > heaviest ? m1 : heaviest;

            slowest = v1 < slowest ? v1 : slowest;
            fastest = v1 > fastest ? v1 : fastest;

            mass += m1;

            for (var obj2 of node.childNodes) {
                if (obj1 != obj2) {
                    var x1 = parseFloat(obj1.getAttribute("cx"));
                    var y1 = parseFloat(obj1.getAttribute("cy"));

                    var x2 = parseFloat(obj2.getAttribute("cx"));
                    var y2 = parseFloat(obj2.getAttribute("cy"));

                    var d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));

                    var r2 = parseFloat(obj2.getAttribute("r"));

                    var density2 = parseFloat(obj2.getAttribute("fill-opacity"));
                    var m2 = r2 * r2 * r2 * base_density * density2;

                    potential += potential_E(m1, m2, d);
                }
            }
        }

        return {
            kinetic: kinetic,
            potential: potential,
            binding: binding,
            total: kinetic + potential + binding,
            lightest: lightest,
            heaviest: heaviest,
            slowest: slowest,
            fastest: fastest,
            mass: mass,
            pop: node.childNodes.length
        };
    }

    var update = setInterval(function () {
        while (resolve_collisions(frame)) ;
        update_velocity(frame);
        update_position(frame);
    }, update_period)

    var probe = setInterval(function () {
        console.log(analyse_system(frame));
    }, probe_period);
    // clearInterval(probe);
</script>

</body>
</html>
