<!DOCTYPE html>
<html lang="en" style="height: 100%;">
<head>
    <meta charset="UTF-8">
    <title>Rotation</title>
    <style>
        circle {
            transition: r 0.5s; /* chrome only for now :( */
        }
    </style>
</head>
<body style="height: 100%; margin: 0">
<svg id="frame" height="100%" width="100%"></svg>
<script>
    const n_objs = 40;

    const dt = .03;
    const base_density = 10;

    const update_period = 50;
    const probe_period = 5000;

    const max_velocity = 80;
    const max_r = 25;

    const G = .5;
    const E_scale = .000001;

    const collision_unbind_E_ratio = .01;
    const collision_kinetic_E_ratio = .99;

    function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }


    function Vxy(v1x, v1y, v2x = 0, v2y = 0) {
        return Math.sqrt((v1x - v2x) * (v1x - v2x) + (v1y - v2y) * (v1y - v2y));
    }

    function kinetic_E(m, v) {
        return E_scale * 0.5 * m * v * v;
    }

    function binding_E(m, r) {
        return E_scale * .6 * G * m * m / r;
    }

    function potential_E(m1, m2, d) {
        return E_scale * -G * m1 * m2 / d;
    }

    function add_objects(node, objects) {
        for (const obj of objects) {
            const element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            for (let prop in obj) {
                element.setAttribute(prop, obj[prop]);
            }
            node.appendChild(element);
        }
    }

    function cleaning(node, min_size) {
        Array.from(node.childNodes).filter(obj => obj.getAttribute("r") < min_size).map(obj => node.removeChild(obj));
    }

    function center_on(node, obj) {
        const x0 = node.getBoundingClientRect().width / 2;
        const y0 = node.getBoundingClientRect().height / 2;
        const x = parseFloat(obj.getAttribute("cx"));
        const y = parseFloat(obj.getAttribute("cy"));

        const dx = x0 - x;
        const dy = y0 - y;

        for (const obj of node.childNodes) {
            const x = parseFloat(obj.getAttribute("cx"));
            const y = parseFloat(obj.getAttribute("cy"));
            obj.setAttribute("cx", x + dx);
            obj.setAttribute("cy", y + dy);
        }
    }


    function center_on_max_r(node) {
        let max_r = 0;
        let max_obj;

        for (const obj of node.childNodes) {
            const r = parseFloat(obj.getAttribute('r'));
            if (r > max_r) {
                max_r = r;
                max_obj = obj;
            }
        }
        center_on(node, max_obj);
    }

    const frame = document.getElementById("frame");

    const starting_objects = [
        // {name: "obj0", cx: 500, cy: 300, r: 80, fill: "rgb(255,255,0)", "fill-opacity": "0.8", vx: 0, vy: 0},
        // {name: "obj1", cx: 200, cy: 100, r: 22, fill: "rgb(247,8,76)", "fill-opacity": "0.8", vx: 0, vy: 50},
        // {name: "obj2", cx: 200, cy: 500, r: 22, fill: "rgb(5,130,202)", "fill-opacity": "0.8", vx: 0, vy: -70},
        // {name: "obj3", cx: 150, cy: 250, r: 20, fill: "#0582ca", "fill-opacity": "0.8", vx: -5, vy: 5},
    ];
    for (let i = 0; i < n_objs; ++i) {
        starting_objects.push({
                name: i,
                cx: randInt(frame.getBoundingClientRect().width / 4, frame.getBoundingClientRect().width / 2 + frame.getBoundingClientRect().width / 4),
                cy: randInt(frame.getBoundingClientRect().width / 4, frame.getBoundingClientRect().height / 2 + frame.getBoundingClientRect().height / 4),
                r: randInt(1, max_r),
                fill: `rgb(${randInt(0, 255)}, ${randInt(0, 255)}, ${randInt(0, 255)})`,
                // "fill-opacity": Math.random(),
                "fill-opacity": 1,
                vx: randInt(-max_velocity, max_velocity),
                vy: randInt(-max_velocity, max_velocity),
            }
        );
    }

    // Init
    add_objects(frame, starting_objects);


    function resolve_collisions(node) {
        for (let obj1 of node.childNodes) {
            for (let obj2 of node.childNodes) {
                if (obj1 !== obj2) {
                    const x1 = parseFloat(obj1.getAttribute("cx"));
                    const y1 = parseFloat(obj1.getAttribute("cy"));

                    const x2 = parseFloat(obj2.getAttribute("cx"));
                    const y2 = parseFloat(obj2.getAttribute("cy"));

                    const r1 = parseFloat(obj1.getAttribute("r"));
                    let r2 = parseFloat(obj2.getAttribute("r"));

                    const d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                    if (d < r1 + r2) {
                        r2 *= d / (r2 + r1);

                        const v1_x = parseFloat(obj1.getAttribute("vx"));
                        const v1_y = parseFloat(obj1.getAttribute("vy"));
                        const density1 = parseFloat(obj1.getAttribute("fill-opacity"));
                        const m1 = r1 * r1 * r1 * base_density * density1;

                        const v2_x = parseFloat(obj2.getAttribute("vx"));
                        const v2_y = parseFloat(obj2.getAttribute("vy"));
                        const density2 = parseFloat(obj2.getAttribute("fill-opacity"));
                        const m2 = r2 * r2 * r2 * base_density * density2;

                        const m = m1 + m2;

                        if (m1 > m2) {
                            var x = x1, y = y1;
                            var other_x = x2, other_y = y2;
                        } else {
                            var x = x2, y = y2;
                            var other_x = x1, other_y = y1;
                        }
                        // const x = (m1 * x1 + m2 * x2) / m;
                        // const y = (m1 * y1 + m2 * y2) / m;

                        const v_x = (m1 * v1_x + m2 * v2_x) / m;
                        const v_y = (m1 * v1_y + m2 * v2_y) / m;

                        const density = (m1 * density1 + m2 * density2) / m;

                        let r = Math.cbrt(m / (base_density * density));

                        const rgb1 = obj1.getAttribute('fill').match(/\d+/g).map((e) => parseFloat(e));
                        const rgb2 = obj2.getAttribute('fill').match(/\d+/g).map((e) => parseFloat(e));
                        const rgb = rgb1.map((e, i) => Math.round((m1 * e + m2 * rgb2[i]) / m));

                        const fill = `rgb(${rgb.join(',')})`;

                        const v1 = Vxy(v1_x, v1_y);
                        const v2 = Vxy(v2_x, v2_y);
                        const v = Vxy(v_x, v_y);

                        const deltaKinetic = kinetic_E(m1, v1) + kinetic_E(m2, v2) - kinetic_E(m, v);
                        if (5 * deltaKinetic > binding_E(m, r)) {
                            const Eu = deltaKinetic * collision_unbind_E_ratio;
                            const Ek = deltaKinetic * collision_kinetic_E_ratio;

                            const unbinded_mass = Math.min(Eu / binding_E(m, r), 1) * m;
                            new_m = m - unbinded_mass;
                            r = Math.cbrt(new_m / (base_density * density));

                            const new_objs = [];
                            if (unbinded_mass * 2 < m) {
                                // const nb_new_objs = Math.round(1 / (.1 + Math.random() * .9));
                                const nb_new_objs = randInt(1, 10);
                                const new_r = Math.cbrt(unbinded_mass / (nb_new_objs * base_density * density));
                                const new_v = 100 * Math.sqrt(2 * Ek / unbinded_mass);

                                const x0 = x - (r + new_r + 1) * (x - other_x) / d;
                                const y0 = y - (r + new_r + 1) * (y - other_y) / d;

                                if (nb_new_objs % 2) {
                                    for (let i = Math.ceil(-nb_new_objs / 2); i < nb_new_objs / 2; ++i) {
                                        let theta = Math.PI / (nb_new_objs + 1) * i + Math.random() * 2 - 1;
                                        new_objs.push({
                                            name: `${obj1.getAttribute("name")}_${i}`,
                                            cx: x0 - 2.5 * i * new_r * (y - other_y) / d,
                                            cy: y0 - 2.5 * i * new_r * (other_x - x) / d,
                                            r: new_r,
                                            fill: fill,
                                            "fill-opacity": 1,
                                            vx: v_x + Math.cos(theta) * new_v * (other_x - x) / d - Math.sin(theta) * new_v * (y - other_y) / d,
                                            vy: v_y + Math.cos(theta) * new_v * (other_y - y) / d - Math.sin(theta) * new_v * (other_x - x) / d,
                                        });
                                    }
                                } else {
                                    for (let i = -nb_new_objs / 2; i < 1 + nb_new_objs / 2; ++i) {
                                        if (i) {
                                            let theta = Math.PI / (nb_new_objs + 1) * (i - .5) + Math.random() * 2 - 1;
                                            new_objs.push({
                                                name: `${obj1.getAttribute("name")}_${i}`,
                                                cx: x0 - 2.5 * (i + 0.5) * new_r * (y - other_y) / d,
                                                cy: y0 - 2.5 * (i + 0.5) * new_r * (other_x - x) / d,
                                                r: new_r,
                                                fill: fill,
                                                "fill-opacity": 1,
                                                vx: v_x + Math.cos(theta) * new_v * (other_x - x) / d - Math.sin(theta) * new_v * (y - other_y) / d,
                                                vy: v_y + Math.cos(theta) * new_v * (other_y - y) / d - Math.sin(theta) * new_v * (other_x - x) / d,
                                            });
                                        }
                                    }
                                }
                            } else if (Math.cbrt(m / (base_density * density)) > 2) {
                                const nb_new_objs = randInt(4, 10);
                                const new_r = Math.cbrt(m / (nb_new_objs * base_density * density));
                                const R = 1.5 * nb_new_objs * new_r / Math.PI;

                                const E = deltaKinetic + binding_E(m, r) - nb_new_objs * binding_E(m / nb_new_objs, new_r);
                                const v = 500 * Math.sqrt(2 * E / m);
                                for (let i = 0; i < nb_new_objs; ++i) {
                                    let theta = i * 2 * Math.PI / nb_new_objs + Math.random() * 2 - 1;
                                    new_objs.push({
                                        name: `${obj1.getAttribute("name")}_${i}`,
                                        cx: x + R * Math.cos(theta) * (x - other_x) / d + R * Math.sin(theta) * (y - other_y) / d,
                                        cy: y + R * Math.cos(theta) * (y - other_y) / d + R * Math.sin(theta) * (other_x - x) / d,
                                        r: new_r,
                                        fill: fill,
                                        "fill-opacity": 1,
                                        vx: v_x + v * Math.cos(theta) * (x - other_x) / d + v * Math.sin(theta) * (y - other_y) / d,
                                        vy: v_y + v * Math.cos(theta) * (y - other_y) / d + v * Math.sin(theta) * (other_x - x) / d
                                    });
                                }
                                frame.removeChild(obj1);
                            }
                            add_objects(node, new_objs);
                        }
                        obj1.setAttribute("vx", v_x);
                        obj1.setAttribute("vy", v_y);
                        obj1.setAttribute("r", r);
                        obj1.setAttribute("density", density);
                        obj1.setAttribute("cx", x);
                        obj1.setAttribute("cy", y);
                        obj1.setAttribute("fill", fill);
                        frame.removeChild(obj2);
                        return true;
                    }
                }
            }
        }
        return false;
    }


    function update_velocity(node) {
        for (const obj1 of node.childNodes) {
            for (const obj2 of node.childNodes) {
                if (obj1 !== obj2) {
                    const x1 = parseFloat(obj1.getAttribute("cx"));
                    const y1 = parseFloat(obj1.getAttribute("cy"));

                    const x2 = parseFloat(obj2.getAttribute("cx"));
                    const y2 = parseFloat(obj2.getAttribute("cy"));

                    const r1 = parseFloat(obj1.getAttribute("r"));
                    let r2 = parseFloat(obj2.getAttribute("r"));

                    const d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                    if (d < r1 + r2) {
                        r2 *= d / (r2 + r1);
                    }

                    const density2 = parseFloat(obj2.getAttribute("fill-opacity"));
                    const m2 = r2 * r2 * r2 * base_density * density2;

                    const F = G * m2 / (d * d * d);

                    const v1_x = parseFloat(obj1.getAttribute("vx"));
                    const v1_y = parseFloat(obj1.getAttribute("vy"));

                    obj1.setAttribute("vx", v1_x + (x2 - x1) * F * dt);
                    obj1.setAttribute("vy", v1_y + (y2 - y1) * F * dt);
                }
            }
        }
    }

    function update_position(node) {
        for (const obj of node.childNodes) {
            const x = parseFloat(obj.getAttribute("cx"));
            const y = parseFloat(obj.getAttribute("cy"));
            const vx = parseFloat(obj.getAttribute("vx"));
            const vy = parseFloat(obj.getAttribute("vy"));
            obj.setAttribute("cx", x + vx * dt);
            obj.setAttribute("cy", y + vy * dt);
        }
    };

    function analyse_system(node) {
        let kinetic = 0;
        let potential = 0;
        let binding = 0;
        let lightest = Infinity;
        let heaviest = 0;
        let slowest = Infinity;
        let fastest = 0;
        let mass = 0;

        for (const obj1 of node.childNodes) {

            const v1_x = parseFloat(obj1.getAttribute("vx"));
            const v1_y = parseFloat(obj1.getAttribute("vy"));

            const r1 = parseFloat(obj1.getAttribute("r"));

            const density1 = parseFloat(obj1.getAttribute("fill-opacity"));
            const m1 = r1 * r1 * r1 * base_density * density1;

            const v1 = Math.sqrt(v1_x * v1_x + v1_y * v1_y);

            kinetic += kinetic_E(m1, v1);
            binding += binding_E(m1, r1);

            lightest = m1 < lightest ? m1 : lightest;
            heaviest = m1 > heaviest ? m1 : heaviest;

            slowest = v1 < slowest ? v1 : slowest;
            fastest = v1 > fastest ? v1 : fastest;

            mass += m1;

            for (const obj2 of node.childNodes) {
                if (obj1 != obj2) {
                    const x1 = parseFloat(obj1.getAttribute("cx"));
                    const y1 = parseFloat(obj1.getAttribute("cy"));

                    const x2 = parseFloat(obj2.getAttribute("cx"));
                    const y2 = parseFloat(obj2.getAttribute("cy"));

                    const d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));

                    const r2 = parseFloat(obj2.getAttribute("r"));

                    const density2 = parseFloat(obj2.getAttribute("fill-opacity"));
                    const m2 = r2 * r2 * r2 * base_density * density2;

                    potential += potential_E(m1, m2, d);
                }
            }
        }

        return {
            kinetic: kinetic,
            potential: potential,
            binding: binding,
            total: kinetic + potential + binding,
            lightest: lightest,
            heaviest: heaviest,
            slowest: slowest,
            fastest: fastest,
            mass: mass,
            pop: node.childNodes.length
        };
    }

    let update = setInterval(function () {
        while (resolve_collisions(frame)) ;
        cleaning(frame, 0.5);
        update_velocity(frame);
        update_position(frame);
        // center_on_max_r(frame);
    }, update_period)

    let probe = setInterval(function () {
        console.log(analyse_system(frame));
    }, probe_period);
    clearInterval(probe);
</script>

</body>
</html>
